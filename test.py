import os
import time
import torch
import numpy as np
import random
import argparse
import torchvision.transforms as transforms
from models.pix2pix import MainModel
from utils.pix2pixDataLoader import make_dataloaders
from utils.pix2pixMetricMeters import Metrics, lab_to_rgb
from tqdm import tqdm

import warnings
warnings.filterwarnings("ignore", category=UserWarning)
warnings.filterwarnings("ignore", category=FutureWarning)


def set_seed(seed):
    """
    Set seed for reproducibility.

    Parameters:
        seed (int): Seed value to set.

    Returns:
        None
    """
    torch.manual_seed(seed)
    np.random.seed(seed)
    random.seed(seed)
    if torch.cuda.is_available():
        torch.cuda.manual_seed_all(seed)

def process_batch(batch, model):
    """
    Process a batch of images through the model.

    Parameters:
        batch (dict): A dictionary containing input data with keys 'L' and 'ab'. 
                      'L' represents the lightness channel, and 'ab' represents the color channels.
        model (MainModel): The Pix2Pix model used for image colorization.

    Returns:
        tuple: A tuple containing two lists of tensors:
            - real_images (list of torch.Tensor): The ground truth color images converted to tensors.
            - generated_images (list of torch.Tensor): The colorized images generated by the model, converted to tensors.
    """
    # Setup the model with the input batch
    model.setup_input(batch)  # Replace with your model's input setup method
    
    # Perform a forward pass through the model
    model.forward()  # Forward pass
    
    # Extract the generated and real color images
    fake_color = model.fake_color.detach()
    real_color = model.ab
    L = model.L
    
    # Convert the LAB images to RGB color space
    generated_images = lab_to_rgb(L, fake_color)
    real_images = lab_to_rgb(L, real_color)
    
    # Convert the images to PyTorch tensors
    generated_images = [transforms.ToTensor()(img) for img in generated_images]
    real_images = [transforms.ToTensor()(img) for img in real_images]
    
    return real_images, generated_images


def main():
    """
    Main testing loop for the Pix2Pix model.

    Returns:
        None
    """

    parser = argparse.ArgumentParser(description="Train Pix2Pix model for image colorization.")
    parser.add_argument('--batch_size', type=int, default=64, help='Batch size for training and validation.')
    parser.add_argument('--num_workers', type=int, default=4, help='Number of worker threads for data loading.')
    parser.add_argument('--seed', type=int, default=9, help='Seed for reproducibility.')
    parser.add_argument('--save_dir', type=str, default='results', help='Directory to save models and logs.')
    parser.add_argument('--model_name', type=str, default='pix2pix', help='Base name for saving model files.')
    parser.add_argument('--model_dir', type=str, default='experiments', help='Base name for saving model files.')
    parser.add_argument('--test_data_path', type=str, default='coco/val2017', help='Path to testing data.')

    args = parser.parse_args()

    # Set seed for reproducibility
    set_seed(args.seed)

    # Print hyperparameters
    print(f"[INFO] Hyperparameters:")
    print(f"  Batch Size         : {args.batch_size}")
    print(f"  Number of Workers  : {args.num_workers}")
    print(f"  Seed               : {args.seed}")
    print(f"  Save Directory     : {args.save_dir}")
    print(f"  Model Name         : {args.model_name}")
    print(f"  Model Path         : {args.model_dir}")
    print(f"  Testing Data Path : {args.test_data_path}")

    # Create directories
    os.makedirs(args.save_dir, exist_ok=True)

    # Paths
    TEST_PATHS = np.array([os.path.join(args.test_data_path, fname) for fname in os.listdir(args.test_data_path)])


    # Data loader
    test_loader = make_dataloaders(batch_size=args.batch_size, num_workers=args.num_workers, pin_memory=True, paths=TEST_PATHS, split='val')
    print(f"[INFO] Testing Data loaded. Found {len(test_loader.dataset)} images for testing.")
    
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

    # Initialize model
    model = MainModel()
    model.load_state_dict(torch.load(os.path.join(args.model_dir, f'best_model_{args.model_name}.pth'), map_location=device))

    # Initialize FID
    metrics_calculator = Metrics(device)

    fids = []
    ssims = []
    psnrs = []

    # Training loop
    print(f"[INFO] Testing starting ...")

    start_time = time.time()

    with torch.no_grad():
        for batch in tqdm(test_loader):
            real_images, generated_images = process_batch(batch, model)
            fid_score = metrics_calculator.calculate_fid(real_images, generated_images)
            ssim_score = metrics_calculator.calculate_ssim(real_images, generated_images)
            psnr_score = metrics_calculator.calculate_psnr(real_images, generated_images)
            fids.append(fid_score)
            ssims.append(ssim_score)
            psnrs.append(psnr_score)

    # Calculate average metrics for this epoch
    avg_fid = np.mean(fids)
    avg_ssim = np.mean(ssims)
    avg_psnr = np.mean(psnrs)

    print(f"\nResults:")
    print(f"{'-'*50}")
    print(f"  FID Score   : {avg_fid:.4f}")
    print(f"  Mean SSIM   : {avg_ssim:.4f}")
    print(f"  Mean PSNR   : {avg_psnr:.4f} dB")
    print(f"{'-'*50}\n")

    print(f"[INFO] Time: {time.time() - start_time:.2f}s")

    print("Training complete.")

if __name__ == "__main__":
    main()
